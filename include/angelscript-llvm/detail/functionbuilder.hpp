#pragma once

#include <angelscript-llvm/detail/fwd.hpp>
#include <angelscript.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/Instructions.h>
#include <vector>

namespace asllvm::detail
{
class FunctionBuilder
{
	struct InstructionContext
	{
		asDWORD*         pointer;
		const asSBCInfo* info;
		std::size_t      offset;
	};

	public:
	FunctionBuilder(
		JitCompiler&       compiler,
		ModuleBuilder&     module_builder,
		asIScriptFunction& script_function,
		llvm::Function*    llvm_function);

	//! \brief Type used by AngelScript for local variable identifiers.
	//! \details
	//!		- When <= 0, refers to a function parameter. 0 refers to the 1st parameter, -1 to the 2nd, and so on.
	//!		- When >1, refers to a local variable or temporary stack slot.
	//! \note
	//!		Depending on the size of the first parameter, the offset of the first local value might be higher than 1.
	using StackVariableIdentifier = std::int16_t;

	// TODO: exceptions should make more sense than just a std::runtime_error
	//! \brief Generates the LLVM IR for _an entire function_ given its AngelScript bytecode.
	//! \exception Throws a std::runtime_error if code generation has failed.
	llvm::Function* read_bytecode(asDWORD* bytecode, asUINT length);

	//! \brief Generates a function of asJITFunction signature.
	//! \details
	//!		This interacts with the VM registers in order to dispatch the call to the function generated by
	//!		read_bytecode() and return to the VM cleanly.
	llvm::Function* create_wrapper_function();

	private:
	void preprocess_instruction(InstructionContext bytecode);
	void read_instruction(InstructionContext bytecode);

	void emit_stack_integer_trunc(InstructionContext instruction, llvm::Type* source, llvm::Type* destination);
	void emit_stack_integer_sign_extend(InstructionContext instruction, llvm::Type* source, llvm::Type* destination);
	void emit_stack_integer_zero_extend(InstructionContext instruction, llvm::Type* source, llvm::Type* destination);
	void emit_stack_arithmetic(InstructionContext instruction, llvm::Instruction::BinaryOps op, llvm::Type* type);
	void emit_stack_arithmetic_imm(InstructionContext instruction, llvm::Instruction::BinaryOps op, llvm::Type* type);
	void emit_integral_compare(InstructionContext instruction, llvm::Value* lhs, llvm::Value* rhs);
	void emit_system_call(asIScriptFunction& function);

	//! \brief Load a LLVM value of type \p type from a stack variable of identifier \p! i.
	llvm::Value* load_stack_value(StackVariableIdentifier i, llvm::Type* type);

	//! \brief Store a LLVM value to a stack variable of identifier \p i.
	void store_stack_value(StackVariableIdentifier i, llvm::Value* value);

	//! \brief Get a pointer to a stack value of type \p type and identifier \p i.
	llvm::Value* get_stack_value_pointer(StackVariableIdentifier i, llvm::Type* type);

	//! \brief Get a pointer to a stack value of type i32* and identifier \p i.
	llvm::Value* get_stack_value_pointer(StackVariableIdentifier i);

	void         store_return_register_value(llvm::Value* value);
	llvm::Value* load_return_register_value(llvm::Type* type);
	llvm::Value* get_return_register_pointer(llvm::Type* type);

	void insert_label(long offset);
	void preprocess_conditional_branch(InstructionContext instruction);
	void preprocess_unconditional_branch(InstructionContext instruction);

	llvm::BasicBlock* get_branch_target(InstructionContext instruction);
	llvm::BasicBlock* get_conditional_fail_branch_target(InstructionContext instruction);

	void emit_branch_if_missing(llvm::BasicBlock* block);

	JitCompiler&   m_compiler;
	ModuleBuilder& m_module_builder;

	asIScriptFunction& m_script_function;

	llvm::Function*   m_llvm_function;
	llvm::BasicBlock* m_entry_block;

	long m_locals_offset = 0, m_locals_size = 0, m_max_extra_stack_size = 0, m_stack_pointer = 0;

	llvm::AllocaInst* m_locals;
	llvm::AllocaInst* m_value;

	std::map<long, llvm::BasicBlock*> m_jump_map;

	//! \brief Pointer to the RET instruction.
	//! \details
	//!		Functions appear to only have one final RET, which is convenient for our JIT purposes: we only have one
	//!		known exit point.
	asDWORD* m_ret_pointer = nullptr;
};

} // namespace asllvm::detail
